1. 이진트리를 전위순회하는 함수를 작성하시오.
(이진트리의 왼쪽자식번호는 리스트 left, 오른쪽은 리스트 right에 부모번호를 인덱스로 저장되어 있다. 자식이 없는 경우 0으로 저장)

[정답코드]
def pre_order(T):   # 전위순회, 방문한 정점(부모) 먼저 처리
    if T:   # 0이 아니면 (존재하는 정점이면)
        print(T)    # visit(T) T에서 할일 처리
        pre_order(left[T])  # 왼쪽 자식(서브트리)로 이동
        pre_order(right[T]) # 오른쪽 자식(서브트리)로 이동

2. 인접리스트로 표현된 그래프의 정점을 DFS 알고리즘으로 한 번씩 방문하며, 방문한 순서대로 정점 번호를 출력하는 재귀 함수를 작성하시오.
visited는 정점 수에 맞게 선언되어 있고, graph는 인접리스트이다.

[정답 코드]
def dfs(node):
    print(node, end=' ')

    # 다음 재귀 호출
    # node 로 부터 갈 수 있는 노드들을 모두 확인
    # --> 그 중에서 한 곳으로 진행
    for next_node in graph[node]:
        # 이미 방문한 정점은 생략
        if visited[next_node]:
            continue

        visited[next_node] = 1  # 방문처리
        dfs(next_node)

3. BFS 알고리즘으로 탐색하는 정점 번호를 순서대로 출력하는 함수를 작성하시오.
(인접리스트 graph가 주어지며, visited는 미리 선언되어 있고, deque()을 사용할 수 있음)

[정답 코드]
def bfs(start_node):
    # q의 의미: 다음에 방문해야 할 노드들 (후보열, 대기열)
    q = deque([start_node])  # 시작점을 queue 에 넣고 시작
    visited[start_node] = 1

    while q:
        # 1. 가장 앞의 노드를 뽑는다
        # 2. 해당 노드에서 갈 수 있는 노드들을 queue 에 넣는다.
        now = q.popleft()

        print(now, end=' ')

        for next_node in graph[now]:
            # 방문했으면 continue
            if visited[next_node]:
                continue

            visited[next_node] = 1
            q.append(next_node)

