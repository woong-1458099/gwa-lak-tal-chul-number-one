#### Vue 의 컴포넌트 구조
- 상태(state), 뷰(view), 기능(Actions) 은 " 단방향 데이터 흐름 " 으로 상호작용하고 있음
## Vite 
빠른 개발 환경을 위한 빌드 도구와 개발 서버를 제공하는 프론트 엔드 개발 툴
#### Pinia
## Vue 공식 상태 관리 라이브러리
- Pinia 는 여러 컴포넌트가 함께 사용해야 하는 공통 데이터를 중앙 저장소에서의 통합 관리를 도와주는 Vue의 공식 상태 관리 라이브러리
- Props나 emit으로 복잡하게 데이터를 전달할 필요 없이, 어떤 컴포넌트든 이 중앙 저장소에 직접 접근하여 데이터를 읽거나 수정할 수 있다
### Pinia 설치
- npm create vue@latest
- space to select - > Pinia

### Pinia 구성 요소 : store
- 공통 데이터를 관리하는 중앙 저장소
- 모든 컴포넌트가 공유하는 상태이며, 기능이 작성됨

### Pinia 구성 요소 : state
- 중앙 저장소에 저장되는 반응형 상태(데이터)
- 해당 값(count) 를 변경하면, 이 데이터를 사용하고 있는 모든 컴포넌트의 화면은 알아서 업데이트 됨
- ref() 와 같은 역할을 함

### Pinia 구성 요소 : getters
- 계산된 값
- state를 기반으로 파생된 값을 정의하는 것
- computed()와 똑같은 역할을 함

### Pinia 구성 요소 : actions
- state를 변경하는 역할
- methods 같은 역할을 함

### Pinia 구성 요소 : 반환 값
- Pinia의 상태들을 사용하려면 반드시 반환해야 함
- store에서는 공유 하지 않는 private한 상태 속성을 가지지 않음

### Pinia 구성 용소 : plugin
- 애플리케이션의 상태 관리에 필요한 추가 기능을 제공하거나 확장하는 도구나 모듈
- 애플리케이션의 상태 관리를 더욱 간편하고 유연하게 만들어주며, 패키지 매니저로 설치 이후 별도 설정을 통해 추가 된다

Pinia -> 상태(state) 저장소, 모든 컴포넌트가 공유하는 데이터 창고
Router -> 화면 이동 담당 , URL 에 따라 어떤 화면을 보여줄지 결정
Components -> UI 단위 조각, 재사용 가능한 UI 블록

1. Pinia store가 왜 이렇게 생겼나?
export const useBalanceStore = defineStore('balance', {
  state: () => ({
    balances: [
      { name: '김하나', balance: 100000 },
      ...
    ]
  }),

## defineStore()?

store를 만드는 공식 문법
→ “balance라는 창고를 만들겠다!”

## state() {} ?

store가 가지고 있는 실제 데이터
→ balances 배열이 여기에 저장됨

getBalanceByName: (state) => {
  return (name) => state.balances.find((item) => item.name === name)
}

## 왜 getter 안에 함수를 넣지?

UpdateView는 URL로 들어오니까 “이름만 알고 있음”

예: /update/김하나

그래서 이 이름으로 Pinia에서 해당 사람 데이터를 찾아오는 기능이 필요함
→ 그걸 getter가 담당

컴포넌트는 “김하나”만 알고 있음
Pinia가 balances에서 김하나를 찾아줌 이 구조 때문에 getter가 함수 반환 형태가 필요했던 것.

## 2. Router가 왜 이렇게 생겼나?
{
  path: '/update/:name',
  name: 'update',
  component: UpdateView
}

✔ :name이 의미하는 것?
URL의 “변수”라는 뜻

예:

/update/김하나
/update/김두리


이 둘 모두 UpdateView로 이동함
그리고 params.name으로 “김하나”, “김두리”를 얻어올 수 있음

##  3. MainPage 컴포넌트가 하는 일
<button @click="goUpdate">updateBalance</button>
눌렀을 때 router로 이동:

router.push({
  name: 'update',
  params: { name: props.balance.name }
})


왜 굳이 params로 이름을 보내나?
-> UpdateView가 어떤 사람 데이터를 수정할지 판단해야 하기 때문

## 4. UpdateView가 하는 일
const target = computed(() => store.getBalanceByName(route.params.name))


route.params.name → URL에서 받은 이름

store.getBalanceByName(name) → Pinia에서 그 사람 객체 찾아줌

즉,

“김하나 페이지에 왔다”
→ 김하나 객체를 Pinia에서 찾아 화면에 띄움


증가 버튼:
target.value.balance += 1000

## Pinia state는 반응형(reactive) 그래서 값을 바꾸면 화면이 즉시 업데이트됨!!



# balances는 Pinia에 저장됨
# MainView에서 balances를 화면에 렌더링
# 각 사람마다 "updateBalance" 클릭
# Router가 /update/사람이름 으로 이동
# UpdateView가 params.name을 읽어서 그 사람 객체를 store에서 찾아옴
# . 버튼 누르면 balance += 1000
# Pinia가 바뀌면 화면도 자동으로 업데이트됨