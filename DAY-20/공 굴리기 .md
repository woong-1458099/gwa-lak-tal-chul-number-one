1. 문제 설명

N×N 크기의 격자판이 있고, 각 칸에는 1 이상 99 이하의 정수가 하나씩 적혀 있다.
플레이어는 어느 칸에서든 공을 한 번 굴릴 수 있으며, 공은 다음 규칙에 따라 상하좌우로 이동한다.

공은 상/하/좌/우 중 현재 칸보다 숫자가 작은 칸으로만 이동할 수 있다.

그 중에서 숫자가 가장 작은 칸으로 이동한다.

가장 작은 수를 가진 칸이 여러 개라면 상  하  좌  우 순으로 우선순위를 두어 이동 방향을 결정한다.

네 방향 중 현재 칸보다 작은 숫자가 하나도 없으면 이동을 멈춘다.

이 때, 시작 칸을 포함하여 공이 지나간 칸의 개수를 “이동 칸 수”라고 할 때,
격자판에서 적절한 시작 위치를 골라 공을 굴렸을 때 얻을 수 있는 최대 이동 칸 수를 구하는 문제이다.

2. 문제 접근 방식

“모든 칸을 시작점 후보로 본다”는 관점에서 접근한다.

N이 최대 10이므로, N² = 100개의 시작점을 전부 시도해봐도 충분히 가능.

각 시작점에서 규칙에 맞게 공을 굴리는 과정을 그대로 시뮬레이션 한다.

상/하/좌/우 네 방향을 확인하면서
→ 현재 값보다 작은 칸들만 후보로 두고
→ 그 중 가장 작은 값을 가진 칸으로 이동
→ 없으면 종료

이렇게 얻은 이동 칸 수의 최댓값을 갱신하는 완전탐색 + 구현 문제로 볼 수 있다.

3. 필요한 알고리즘 개념

델타 배열(방향 배열)

상/하/좌/우를 나타내는 di, dj를 사용해 2차원 격자 이동을 편하게 구현.

방향의 순서(상→하→좌→우) 자체가 곧 우선순위가 되기 때문에,
같은 값의 최소 후보가 있을 때 자동으로 우선순위를 만족한다.

2차원 배열 & 인덱스 다루기

matrix[i][j] 형태로 격자 값을 읽고 쓰는 기본기.

인덱스 범위 체크 : 0 <= ni < N 과 0 <= nj < N

완전탐색

모든 칸을 시작점으로 삼아서 전부 시도해보는 방식.

N이 작기 때문에 가능한 전략.

시뮬레이션(구현)

문제에서 주어진 규칙(이동 조건, 방향 우선순위)을 코드로 그대로 옮기는 능력.


4. 풀이 과정

입력 받기

테스트케이스 개수 T를 입력받는다.

각 테스트케이스마다

정수 N을 입력받고,

N줄에 걸쳐 정수 N개씩 받아 N×N 격자 matrix에 저장한다.

방향 배열 설정

상, 하, 좌, 우를 나타내는 델타 배열을 준비한다.

di = [-1, 1, 0, 0]   # 상, 하, 좌, 우의 행 변화량
dj = [0, 0, -1, 1]   # 상, 하, 좌, 우의 열 변화량


이 순서(0: 상, 1: 하, 2: 좌, 3: 우)가 그대로
“같은 값일 때 상→하→좌→우 우선순위”를 만족하도록 사용된다.

모든 칸을 시작점으로 시도

max_count = 0 으로 초기화하고,

모든 좌표 (i, j) 에 대해 다음을 수행:

현재 공 위치를 (ci, cj) = (i, j)로 둔다.

방문 칸 수 cnt = 0으로 시작.

while 반복을 돌며 다음을 수행:

cnt += 1 : 현재 칸을 방문했으므로 1 증가.

min_num 을 매우 큰 값(예: 1,000,000)으로 초기화.

next_pos = None 으로 두고 다음 이동 칸을 찾는다.

4방향에 대해:

격자 범위를 벗어난 경우는 건너뛴다.

현재 칸 값보다 작은 값인 경우만 후보로 고려한다.

그 중에서 지금까지의 min_num 보다 더 작은 값이면
min_num, next_pos 갱신.

이 때, 방향을 0,1,2,3 순서대로 탐색하므로
같은 값일 경우 상→하→좌→우 우선순위가 유지된다.

4방향을 다 확인한 뒤,

next_pos 가 None이면 더 이상 갈 곳이 없으므로 while 종료.

아니라면 ci, cj를 next_pos로 갱신하고 다시 반복.

최대 이동 칸 수 갱신

각 시작점마다 구한 cnt를 max_count와 비교해서,
더 큰 값으로 max_count를 갱신한다.

정답 출력

한 테스트케이스에 대한 모든 시작점을 확인한 뒤,

형식에 맞게 #테스트케이스번호 최대칸수를 출력한다.

print(f"#{tc} {max_count}")
